<!DOCTYPE html>
<html lang="zh">
<head>
    <!--
        lang="zh" 指明页面的主要语言为中文，利于搜索引擎与无障碍工具。
    -->
    <meta charset="UTF-8">
    <!--
        viewport 设置保证在不同设备（尤其是移动端）上按比例缩放，
        width=device-width: 视口宽度等于设备宽度
        initial-scale=1.0: 初始缩放比例 1
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三屏幻灯片壁纸</title>

    <!--
        这里使用内联 <style>，方便单文件演示。
        实际项目可考虑抽离到独立 CSS 文件。
    -->
    <style>
        /*
            body, html 设为 100% 尺寸，清除默认 margin/padding，
            并禁止滚动（overflow: hidden），背景纯黑。
        */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }

        /*
            外层容器使用 flex 布局 水平排列三个面板。
        */
        #slideshow-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: row;
        }

        /*
            每个面板 flex:1 平分宽度，position:relative 以便其子元素（绝对定位的 img/video）覆盖填充。
            overflow:hidden 防止媒体溢出。
        */
        .slideshow-panel {
            flex: 1;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        /* 全屏布局容器 */
        #fullscreen-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
            background-color: #000;
            z-index: 1000;
        }

        /* 隐藏类 */
        .hidden {
            display: none;
        }

        /* 全屏布局下的媒体元素 */
        #fullscreen-container img, #fullscreen-container video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        /* 激活（当前显示）媒体添加 active 类，令其淡入显示 */
        #fullscreen-container img.active, #fullscreen-container video.active {
            opacity: 1;
        }

        /*
            面板内的图片与视频采用绝对定位 + 宽高 100%，
            object-fit: cover 保持比例填满裁剪以适应各种分辨率。
            初始透明度 0，使用过渡实现淡入。
        */
        .slideshow-panel img, .slideshow-panel video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover; /* 保持比例并填满视口，允许裁剪 */
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        /* 激活（当前显示）媒体添加 active 类，令其淡入显示 */
        .slideshow-panel img.active, .slideshow-panel video.active {
            opacity: 1;
        }

        /* 去掉视频的默认外轮廓（聚焦时的边框） */
        .slideshow-panel video {
            outline: none;
        }

        /* 面板之间加一条轻微分隔线（最后一个不加） */
        .slideshow-panel:not(:last-child) {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <!--
        三个面板：左 / 中 / 右。
        通过 JS 分别独立随机轮播，实现互不干扰的多屏幻灯效果。
    -->
    <div id="slideshow-container">
        <div class="slideshow-panel" id="panel-left"></div>
        <div class="slideshow-panel" id="panel-center"></div>
        <div class="slideshow-panel" id="panel-right"></div>
    </div>

    <!-- 全屏布局容器 -->
    <div id="fullscreen-container" class="fullscreen-layout hidden">
    </div>

    <!--
        下方脚本：
        1. 异步获取媒体文件列表 list.json（应放在 ./media/ 目录）
        2. 为三个面板初始化并循环播放（随机间隔 + 随机下一个媒体）
        3. 支持图片与常见视频格式（扩展在 isVideoFile 中）
    -->
    <script>
        // ===================== 基础数据 =====================
        // 用于存储媒体文件信息（包含尺寸和方向），由 list.json 返回
        let mediaList = [];

        // 当前布局模式 ('split' 或 'fullscreen')
        let currentLayout = 'split';

        // 存储面板循环的定时器ID，用于暂停/恢复
        let panelTimers = new Map();

        // 全屏容器的媒体数据
        let fullscreenMediaData = {
            currentIndex: -1,
            isPlayingVideo: false,
            mediaElement: null
        };

        // 打乱后的资源序列，用于顺序播放
        let shuffledMediaList = [];

        // 全局下一个资源索引，确保不重复使用
        let nextGlobalIndex = 0;

        // 每个面板的当前播放索引
        let panelIndices = new Map();

        // ===================== 载入媒体列表 =====================
        // fetch('./media/list.json'): 向同目录下 media 文件夹请求 list.json
        // list.json 现在是一个包含媒体信息的对象数组
        fetch('./media/list.json')
            .then(response => response.json())
            .then(data => {
                mediaList = data;
                initSlideshow(); // 列表拉取成功后开始初始化
            })
            .catch(error => {
                console.error('Error loading media list:', error);
            });

        // ===================== 初始化入口 =====================
        /**
         * initSlideshow
         * 说明: 若成功获取媒体列表，为三个面板分别按不同起始索引初始化。
         * 注意: startIndex 只是初始显示顺序，后续播放采用顺序选择（基于打乱的序列）。
         */
        function initSlideshow() {
            if (mediaList.length === 0) return; // 没有媒体则不处理

            // 创建重新排列的资源序列（确保portrait资源至少3个连续）
            shuffledMediaList = rearrangeMediaList(mediaList);

            // 初始化全局索引
            nextGlobalIndex = 3; // 前3个资源用于初始化三个面板

            // 为三个面板分配不同的初始资源索引（使用重新排列序列中的前3个资源）
            panelIndices.set('panel-left', 0);
            panelIndices.set('panel-center', 1);
            panelIndices.set('panel-right', 2);

            // 初始化三个面板
            initPanel('panel-left', panelIndices.get('panel-left'));
            initPanel('panel-center', panelIndices.get('panel-center'));
            initPanel('panel-right', panelIndices.get('panel-right'));
        }

        // ===================== 数组打乱函数 =====================
        /**
         * shuffleArray(array)
         * @param {Array} array - 需要打乱的数组
         * @returns {Array} 打乱后的数组
         * 说明: 使用 Fisher-Yates 算法打乱数组
         */
        function shuffleArray(array) {
            const newArray = [...array]; // 创建副本
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // ===================== 重新排列媒体列表以确保portrait资源至少3个连续 =====================
        /**
         * rearrangeMediaList(mediaList)
         * @param {Array} mediaList - 媒体列表
         * @returns {Array} 重新排列后的媒体列表
         * 说明: 确保portrait资源至少以3个为一组连续排列
         */
        function rearrangeMediaList(mediaList) {
            // 分离portrait和landscape资源
            const portraits = mediaList.filter(media => media.orientation === 'portrait');
            const landscapes = mediaList.filter(media => media.orientation === 'landscape');

            // 如果portrait资源少于3个，直接返回打乱的列表
            if (portraits.length < 3) {
                return shuffleArray(mediaList);
            }

            // 打乱两个列表
            const shuffledPortraits = shuffleArray(portraits);
            const shuffledLandscapes = shuffleArray(landscapes);

            // 创建结果列表
            const result = [];

            // 初始化索引
            let portraitIndex = 0;
            let landscapeIndex = 0;

            // 按组处理资源，确保portrait至少3个连续
            while (portraitIndex < shuffledPortraits.length || landscapeIndex < shuffledLandscapes.length) {
                // 计算剩余的portrait资源
                const remainingPortraits = shuffledPortraits.length - portraitIndex;

                // 如果剩余的portrait资源少于3个，将它们与前面的资源组合
                if (remainingPortraits > 0 && remainingPortraits < 3 && result.length > 0) {
                    // 添加剩余的所有portrait资源到当前组
                    for (let i = 0; i < remainingPortraits; i++) {
                        result.push(shuffledPortraits[portraitIndex++]);
                    }
                } else if (remainingPortraits >= 3) {
                    // 添加3个portrait资源
                    for (let i = 0; i < 3 && portraitIndex < shuffledPortraits.length; i++) {
                        result.push(shuffledPortraits[portraitIndex++]);
                    }
                    // 添加1个landscape资源（如果还有）
                    if (landscapeIndex < shuffledLandscapes.length) {
                        result.push(shuffledLandscapes[landscapeIndex++]);
                    }
                } else {
                    // 处理剩余的情况（portrait资源少于3个且结果列表为空，或者没有更多portrait资源）
                    if (landscapeIndex < shuffledLandscapes.length) {
                        result.push(shuffledLandscapes[landscapeIndex++]);
                    }
                    // 如果还有portrait资源，将它们添加到结果中
                    while (portraitIndex < shuffledPortraits.length) {
                        result.push(shuffledPortraits[portraitIndex++]);
                    }
                }
            }

            return result;
        }

        // ===================== 随机索引生成 =====================
        /**
         * getRandomIndices(count, max)
         * @param {number} count - 需要生成的索引数量
         * @param {number} max - 索引的最大值（不包含）
         * @returns {Array<number>} 不重复的随机索引数组
         * 说明: 生成指定数量的不重复随机索引
         */
        function getRandomIndices(count, max) {
            if (count > max) {
                // 如果需要的索引数量大于最大值，则返回顺序索引
                return Array.from({length: count}, (_, i) => i % max);
            }

            const indices = [];
            const used = new Set();

            for (let i = 0; i < count; i++) {
                let randomIndex;
                do {
                    randomIndex = Math.floor(Math.random() * max);
                } while (used.has(randomIndex) && used.size < max);

                indices.push(randomIndex);
                used.add(randomIndex);
            }

            return indices;
        }

        // ===================== 面板初始化 =====================
        /**
         * initPanel(panelId, startIndex)
         * @param {string} panelId - 面板 DOM 元素 id
         * @param {number} startIndex - 初始显示的媒体索引
         * 说明: 为面板建立一个状态对象 panelData，记录当前索引、视频播放状态等。
         */
        function initPanel(panelId, startIndex) {
            const panel = document.getElementById(panelId);

            const panelData = {
                currentIndex: startIndex,      // 当前正在展示的媒体索引
                isPlayingVideo: false,         // 是否正在播放视频（用于控制定时切换）
                mediaElement: null             // 当前的 <img> 或 <video>
            };

            // 将面板数据存储在元素实例上，便于后续访问
            panel.panelData = panelData;

            // 显示初始媒体
            displayMedia(panel, startIndex);

            // 启动递归循环（随机间隔触发）
            startPanelLoop(panel);
        }

        // ===================== 媒体类型判断 =====================
        /**
         * isVideoFile(filename)
         * @param {string} filename - 文件名
         * @returns {boolean} 是否是视频类型
         * 说明: 用文件扩展名简单判断，可按需要扩展。
         */
        function isVideoFile(filename) {
            const videoExtensions = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.wmv'];
            return videoExtensions.some(ext => filename.toLowerCase().endsWith(ext));
        }

        // ===================== 创建媒体元素 =====================
        /**
         * createMediaElement(filename)
         * @param {string} filename - 文件名
         * @returns {HTMLImageElement|HTMLVideoElement} 对应的媒体元素
         */
        function createMediaElement(filename) {
            if (isVideoFile(filename)) {
                const video = document.createElement('video');
                // 这里不自动 autoplay，在 loadMedia 之后再手动 play，便于捕获错误
                video.autoplay = false;
                video.muted = true;      // 静音播放，防止浏览器自动播放策略阻止
                video.loop = false;      // 播放完后切换到下一个媒体
                video.controls = false;  // 不显示控制条（作为壁纸展示）
                video.playsInline = true;// iOS Safari 内联播放
                return video;
            } else {
                return document.createElement('img');
            }
        }

        // ===================== 加载媒体资源 =====================
        /**
         * loadMedia(mediaElement, filename)
         * @param {HTMLElement} mediaElement - <img> 或 <video>
         * @param {string} filename - 媒体文件名
         * @returns {Promise<void>} 媒体加载完成或失败
         * 说明: 对图片先新建 Image 进行预加载，成功后再赋值；
         *       对视频使用 onloadeddata 事件；失败时 reject，外层会处理。
         */
        function loadMedia(mediaElement, filename) {
            return new Promise((resolve, reject) => {
                // 清除之前的 class（例如 active）
                mediaElement.className = '';

                if (mediaElement.tagName === 'VIDEO') {
                    mediaElement.src = './media/' + filename;
                    mediaElement.onloadeddata = function() {
                        resolve();
                    };
                    mediaElement.onerror = function() {
                        console.error('Failed to load video:', filename);
                        reject();
                    };
                } else {
                    // 图片处理：预先创建一个 Image 对象测试能否加载
                    const img = new Image();
                    img.onload = function() {
                        mediaElement.src = './media/' + filename;
                        resolve();
                    };
                    img.onerror = function() {
                        console.error('Failed to load image:', filename);
                        reject();
                    };
                    img.src = './media/' + filename;
                }
            });
        }

        // ===================== 显示指定媒体 =====================
        /**
         * displayMedia(panel, index)
         * @param {HTMLElement} panel - 面板元素
         * @param {number} index - 要显示的媒体索引
         * 说明: 创建新媒体元素并替换旧的；加载成功后添加 active 类实现淡入；若是视频则播放并监听结束。
         */
        function displayMedia(panel, index) {
            const panelData = panel.panelData;
            // 使用重新排列后的资源列表
            const mediaInfo = shuffledMediaList[index];
            const filename = mediaInfo.filename;
            if (!filename) return;

            // 检查是否需要切换布局
            if (mediaInfo.orientation === 'landscape') {
                // 横屏媒体，切换到全屏布局
                // 需要找到在原始列表中的索引
                const originalIndex = mediaList.findIndex(item => item.filename === mediaInfo.filename);
                switchToFullscreenLayout(originalIndex);
                return;
            }

            // 竖屏媒体，保持三栏布局
            if (currentLayout !== 'split') {
                switchToSplitLayout();
            }

            // 创建新的媒体元素
            const newMediaElement = createMediaElement(filename);
            newMediaElement.alt = 'Slideshow Media'; // 若为图片，提供基本替代文本

            // 移除旧元素（直接删除，无淡出动画；可按需扩展）
            if (panelData.mediaElement) {
                panel.removeChild(panelData.mediaElement);
            }

            // 记录并添加到 DOM
            panelData.mediaElement = newMediaElement;
            panel.appendChild(panelData.mediaElement);

            // 加载文件
            loadMedia(panelData.mediaElement, filename).then(() => {
                // 加载成功，显示（淡入）
                panelData.mediaElement.classList.add('active');

                // 视频处理
                if (panelData.mediaElement.tagName === 'VIDEO') {
                    panelData.isPlayingVideo = true; // 标记正在播放

                    // 播放完自动切换
                    panelData.mediaElement.onended = function() {
                        panelData.isPlayingVideo = false;
                        if (currentLayout === 'split') {
                            nextMedia(panel);
                        }
                    };

                    // 尝试播放（有可能被浏览器策略拦截，已静音一般不会）
                    panelData.mediaElement.play().catch(e => {
                        console.error('Video play error:', e);
                        // 播放失败当作图片一样直接换下一个
                        panelData.isPlayingVideo = false;
                        if (currentLayout === 'split') {
                            nextMedia(panel);
                        }
                    });
                }
            }).catch(() => {
                // 加载失败：移除占位并尝试下一个
                if (panelData.mediaElement) {
                    panel.removeChild(panelData.mediaElement);
                    panelData.mediaElement = null;
                }
                if (currentLayout === 'split') {
                    nextMedia(panel);
                }
            });
        }

        // ===================== 布局切换函数 =====================
        /**
         * switchToFullscreenLayout(index)
         * @param {number} index - 媒体索引
         * 说明: 切换到全屏布局并显示指定媒体
         */
        function switchToFullscreenLayout(index) {
            // 清除所有面板的定时器
            for (const [panelId, timerId] of panelTimers) {
                clearTimeout(timerId);
            }
            panelTimers.clear();

            // 隐藏三栏布局
            const splitContainer = document.getElementById('slideshow-container');
            splitContainer.classList.add('hidden');

            // 显示全屏布局
            const fullscreenContainer = document.getElementById('fullscreen-container');
            fullscreenContainer.classList.remove('hidden');

            // 更新布局状态
            currentLayout = 'fullscreen';

            // 显示媒体
            displayFullscreenMedia(index);
        }

        /**
         * switchToSplitLayout()
         * 说明: 切换到三栏布局
         */
        function switchToSplitLayout() {
            // 隐藏全屏布局
            document.getElementById('fullscreen-container').classList.add('hidden');

            // 显示三栏布局
            document.getElementById('slideshow-container').classList.remove('hidden');

            // 更新布局状态
            currentLayout = 'split';

            // 重新启动所有面板的循环
            const panels = ['panel-left', 'panel-center', 'panel-right'];
            for (const panelId of panels) {
                const panel = document.getElementById(panelId);
                if (panel && panel.panelData) {
                    startPanelLoop(panel);
                }
            }
        }

        /**
         * displayFullscreenMedia(index)
         * @param {number} index - 媒体索引
         * 说明: 在全屏布局中显示媒体
         */
        function displayFullscreenMedia(index) {
            const mediaInfo = mediaList[index];
            const filename = mediaInfo.filename;
            if (!filename) return;

            const fullscreenContainer = document.getElementById('fullscreen-container');

            // 更新全屏媒体数据
            fullscreenMediaData.currentIndex = index;

            // 创建新的媒体元素
            const newMediaElement = createMediaElement(filename);
            newMediaElement.alt = 'Slideshow Media';

            // 移除旧元素
            if (fullscreenMediaData.mediaElement) {
                fullscreenContainer.removeChild(fullscreenMediaData.mediaElement);
            }

            // 记录并添加到 DOM
            fullscreenMediaData.mediaElement = newMediaElement;
            fullscreenContainer.appendChild(fullscreenMediaData.mediaElement);

            // 加载文件
            loadMedia(fullscreenMediaData.mediaElement, filename).then(() => {
                // 加载成功，显示（淡入）
                fullscreenMediaData.mediaElement.classList.add('active');

                // 视频处理
                if (fullscreenMediaData.mediaElement.tagName === 'VIDEO') {
                    fullscreenMediaData.isPlayingVideo = true;

                    // 播放完自动切换
                    fullscreenMediaData.mediaElement.onended = function() {
                        fullscreenMediaData.isPlayingVideo = false;
                        nextFullscreenMedia();
                    };

                    // 尝试播放
                    fullscreenMediaData.mediaElement.play().catch(e => {
                        console.error('Video play error:', e);
                        fullscreenMediaData.isPlayingVideo = false;
                        nextFullscreenMedia();
                    });
                } else {
                    // 图片处理，设置定时器
                    setTimeout(() => {
                        if (!fullscreenMediaData.isPlayingVideo) {
                            nextFullscreenMedia();
                        }
                    }, Math.floor(Math.random() * 60 + 60) * 1000); // 5-10秒随机间隔
                }
            }).catch(() => {
                // 加载失败，尝试下一个
                if (fullscreenMediaData.mediaElement) {
                    fullscreenContainer.removeChild(fullscreenMediaData.mediaElement);
                    fullscreenMediaData.mediaElement = null;
                }
                nextFullscreenMedia();
            });
        }

        /**
         * nextFullscreenMedia()
         * 说明: 切换到下一个全屏媒体
         */
        function nextFullscreenMedia() {
            if (mediaList.length === 0) return;

            // 获取全局下一个索引
            let nextIndex = nextGlobalIndex++;

            // 检查是否需要重新打乱序列（当索引超过一定倍数时）
            if (nextIndex >= shuffledMediaList.length * 3) {
                // 重新打乱序列
                shuffledMediaList = rearrangeMediaList(mediaList);
                // 重置全局索引
                nextGlobalIndex = 0;
                nextIndex = nextGlobalIndex++;
            }

            // 确保索引在范围内
            nextIndex = nextIndex % shuffledMediaList.length;

            // 从打乱的序列中找到下一个媒体在原始列表中的索引
            const nextMediaInfo = shuffledMediaList[nextIndex];
            const originalIndex = mediaList.findIndex(item => item.filename === nextMediaInfo.filename);

            // 更新全屏媒体数据的当前索引
            fullscreenMediaData.currentIndex = originalIndex;

            if (nextMediaInfo.orientation === 'landscape') {
                // 仍然是横屏，继续全屏布局
                displayFullscreenMedia(originalIndex);
            } else {
                // 竖屏媒体，切换回三栏布局
                switchToSplitLayout();

                // 在三栏布局中选择一个面板显示这个竖屏媒体
                // 使用循环方式选择面板，确保每个面板都有机会显示
                const panels = ['panel-left', 'panel-center', 'panel-right'];
                // 简单的轮询方式选择面板
                const panelCycleIndex = Math.floor(Date.now() / 1000) % 3;
                const panelId = panels[panelCycleIndex];
                const panel = document.getElementById(panelId);
                if (panel && panel.panelData) {
                    // 更新面板索引
                    panelIndices.set(panelId, nextIndex);
                    panel.panelData.currentIndex = originalIndex;
                    // 直接显示媒体，不通过displayMedia函数以避免再次触发布局切换
                    showMedia(panel, originalIndex);
                }
            }
        }

        /**
         * showMedia(panel, index)
         * @param {HTMLElement} panel - 面板元素
         * @param {number} index - 要显示的媒体索引
         * 说明: 直接显示指定媒体，不检查布局切换
         */
        function showMedia(panel, index) {
            const panelData = panel.panelData;
            // 使用重新排列后的资源列表
            const mediaInfo = shuffledMediaList[index];
            const filename = mediaInfo.filename;
            if (!filename) return;

            // 创建新的媒体元素
            const newMediaElement = createMediaElement(filename);
            newMediaElement.alt = 'Slideshow Media'; // 若为图片，提供基本替代文本

            // 移除旧元素（直接删除，无淡出动画；可按需扩展）
            if (panelData.mediaElement) {
                panel.removeChild(panelData.mediaElement);
            }

            // 记录并添加到 DOM
            panelData.mediaElement = newMediaElement;
            panel.appendChild(panelData.mediaElement);

            // 加载文件
            loadMedia(panelData.mediaElement, filename).then(() => {
                // 加载成功，显示（淡入）
                panelData.mediaElement.classList.add('active');

                // 视频处理
                if (panelData.mediaElement.tagName === 'VIDEO') {
                    panelData.isPlayingVideo = true; // 标记正在播放

                    // 播放完自动切换
                    panelData.mediaElement.onended = function() {
                        panelData.isPlayingVideo = false;
                        if (currentLayout === 'split') {
                            nextMedia(panel);
                        }
                    };

                    // 尝试播放（有可能被浏览器策略拦截，已静音一般不会）
                    panelData.mediaElement.play().catch(e => {
                        console.error('Video play error:', e);
                        // 播放失败当作图片一样直接换下一个
                        panelData.isPlayingVideo = false;
                        if (currentLayout === 'split') {
                            nextMedia(panel);
                        }
                    });
                }
            }).catch(() => {
                // 加载失败：移除占位并尝试下一个
                if (panelData.mediaElement) {
                    panel.removeChild(panelData.mediaElement);
                    panelData.mediaElement = null;
                }
                if (currentLayout === 'split') {
                    nextMedia(panel);
                }
            });
        }

        // ===================== 切换到下一个媒体 =====================
        /**
         * nextMedia(panel)
         * @param {HTMLElement} panel - 面板元素
         * 说明: 按顺序选取下一个媒体（基于打乱的序列），更新并显示。
         */
        function nextMedia(panel) {
            const panelData = panel.panelData;
            const panelId = panel.id;

            // 获取全局下一个索引
            let nextIndex = nextGlobalIndex++;

            // 检查是否需要重新打乱序列（当索引超过一定倍数时）
            if (nextIndex >= shuffledMediaList.length * 3) {
                // 重新打乱序列
                shuffledMediaList = rearrangeMediaList(mediaList);
                // 重置全局索引
                nextGlobalIndex = 0;
                nextIndex = nextGlobalIndex++;
            }

            // 确保索引在范围内
            nextIndex = nextIndex % shuffledMediaList.length;

            // 更新面板索引
            panelIndices.set(panelId, nextIndex);

            // 从原始媒体列表中找到对应的索引
            const mediaInfo = shuffledMediaList[nextIndex];
            const originalIndex = mediaList.findIndex(item => item.filename === mediaInfo.filename);

            panelData.currentIndex = originalIndex;
            displayMedia(panel, panelData.currentIndex);
        }

        // ===================== 循环调度（随机间隔） =====================
        /**
         * startPanelLoop(panel)
         * @param {HTMLElement} panel - 面板元素
         * 说明: 生成 5~10 秒的随机间隔，间隔到期如果当前不是视频播放中则调用 nextMedia。
         *       然后递归再次设置新的定时器，实现持续循环。
         */
        function startPanelLoop(panel) {
            const panelData = panel.panelData;

            // 随机间隔（秒）[5,10]
            const interval = Math.floor(Math.random() * 60) + 60; // 5-10秒

            const timerId = setTimeout(() => {
                // 如果当前没有视频在播放，执行切换
                if (!panelData.isPlayingVideo && currentLayout === 'split') {
                    nextMedia(panel);
                }
                // 递归继续循环
                if (currentLayout === 'split') {
                    startPanelLoop(panel);
                }
            }, interval * 1000);

            // 存储定时器ID
            panelTimers.set(panel.id, timerId);
        }
    </script>
</body>
</html>
